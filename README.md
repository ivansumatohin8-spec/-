Объяснение алгоритма (C++):
Базовый случай: Когда индекс достигает конца строки, возвращаем 0

Обработка символа: Текущий символ приводится к нижнему регистру и проверяется на гласность

Рекурсивный вызов: Функция вызывает саму себя для следующего символа

Накопление результата: Суммируем результаты через цепочку возвратов

Временная сложность:
O(n), где n - длина строки

Каждый символ обрабатывается ровно один раз

Количество рекурсивных вызовов равно длине строки

Контрольный вопрос №5
Опишите стратегию «разделяй и властвуй» на примере алгоритма сортировки слиянием

Суть стратегии «разделяй и властвуй»:
Разделяй - разбей проблему на меньшие подпроблемы того же типа

Властвуй - реши подпроблемы рекурсивно

Объединяй - комбинируй решения подпроблем в общее решение

Пример: Сортировка слиянием (Merge Sort)
Шаг 1: РАЗДЕЛЯЙ

Исходный массив делится пополам

Процесс повторяется рекурсивно до тех пор, пока не получатся массивы из одного элемента

Шаг 2: ВЛАСТВУЙ

Массивы из одного элемента считаются уже отсортированными

Рекурсивно сортируем каждую половину

Шаг 3: ОБЪЕДИНЯЙ

Сливаем два отсортированных массива в один упорядоченный массив

Визуальный пример:
text
Исходный массив: [3, 7, 1, 5, 2, 8, 4, 6]

РАЗДЕЛЕНИЕ:
[3, 7, 1, 5] [2, 8, 4, 6]
[3, 7] [1, 5] [2, 8] [4, 6]
[3] [7] [1] [5] [2] [8] [4] [6]  ← базовый случай

ОБЪЕДИНЕНИЕ:
[3, 7] [1, 5] [2, 8] [4, 6]
[1, 3, 5, 7] [2, 4, 6, 8]
[1, 2, 3, 4, 5, 6, 7, 8]  ← отсортированный массив
Почему это «разделяй и властвуй»:
Разделяй: Большая задача (сортировка массива) разбивается на меньшие (сортировка половин)

Властвуй: Каждая подзадача решается независимо рекурсивно

Объединяй: Решения подзадач комбинируются в общее решение через слияние

Преимущества:

Гарантированная временная сложность O(n log n)

Стабильная сортировка

Хорошо работает с большими объемами данных
